# OSS Review Toolkit

| Linux (OpenJDK 8)            | Windows (Oracle JDK 9)          |
| :--------------------------- | :------------------------------ |
[ ![Linux build status][1]][2] | [![Windows build status][3]][4] |

[1]: https://travis-ci.org/heremaps/oss-review-toolkit.svg?branch=master
[2]: https://travis-ci.org/heremaps/oss-review-toolkit
[3]: https://ci.appveyor.com/api/projects/status/hbc1mn5hpo9a4hcq/branch/master?svg=true
[4]: https://ci.appveyor.com/project/heremaps/oss-review-toolkit/branch/master

The OSS Review Toolkit (ORT for short) is a suite of tools to assist with reviewing Free and Open Source Software dependencies in your software. At a high level, it works by analyzing your source code for dependencies, downloading the source code of the dependencies, scanning all source code for license information, and summarizing the results. The different tools in the suite are designed as libraries (for programmatic use) with minimal command line interfaces (for scripted use, [doing one thing and doing it well](https://en.wikipedia.org/wiki/Unix_philosophy#Do_One_Thing_and_Do_It_Well)).

The goal of ORT is to give the Open Source community a toolset that can enable reviews during source code creation by providing open-sourced tooling for developers to do basic compliance checks and get insights on their dependencies.

The toolkit is envisioned to consist out of the following libraries:

* *Analyzer* - determines dependencies of software project even when multiple package managers are used. No changes to software project required.
* *Downloader* - fetches the source code based on output generated by the Analyzer.
* *Scanner* - wrapper around existing copyright/license scanners which takes as input the output of the Downloader and produces standardized output such as [SPDX](https://spdx.org/).
* *Evaluator* * - Evaluates the scan results from Scanner as OK or NOT OK based on user specified approval/rejection ruleset.
* *Advisor* * - Retrieves security advisories based on Analyzer results.
* *Reporter* * - Summarizes the output from Analyzer, Scanner and Evaluator in an interactive UI of found copyrights, licenses and NOT OK issues.
* *Documenter* * - Generates the outcome of the review, e.g. Open Source notices and annotated [SPDX](https://spdx.org/) files that can be included with your deliverable.

\* Libraries still to be implemented, plan is to have a complete MVP suite by Q3 2018.

## Installation

To get started with the OSS Review Toolkit, simply:

1. Ensure OpenJDK 8 or Oracle JDK 8u161 or later (not the JRE as you need the `javac` compiler) is installed and the `JAVA_HOME`
environment variable set.
2. Clone this repository.
3. Change into the repo directory on your machine and run `./gradlew installDist` to setup the build environment (e.g.
get Gradle etc.) and build/install the start scripts for ORT. The individual start scripts can then be run directly from
their respective locations as follows:

* `./analyzer/build/install/analyzer/bin/analyzer`
* `./graph/build/install/graph/bin/graph`
* `./downloader/build/install/downloader/bin/downloader`
* `./scanner/build/install/scanner/bin/scanner`

Make sure that the locale of your system is set to `en_US.UTF-8`, using other locales might lead to issues with parsing
the output of external tools.

## Supported package managers

Currently, the following package managers / build systems can be detected and queried for their managed dependencies:

* [Gradle](https://gradle.org/)
* [Maven](http://maven.apache.org/)
* [SBT](http://www.scala-sbt.org/)
* [NPM](https://www.npmjs.com/)
* [PIP](https://pip.pypa.io/)

## Supported license scanners

ORT comes with some example implementations for wrappers around license / copyright scanners:

* [lc](https://github.com/boyter/lc)
* [Licensee](https://github.com/benbalter/licensee)
* [ScanCode](https://github.com/nexB/scancode-toolkit)

## Supported remote caches

For reusing already known scan results, ORT can currently use one of the following backends as a remote cache:

* [Artifactory](https://jfrog.com/artifactory/)

## Usage

### [analyzer](./analyzer/src/main/kotlin)

The Analyzer determines the dependencies of software projects inside the specified input directory (`-i`). It does so by
querying whatever [supported package manager](./analyzer/src/main/kotlin/managers) is found. No modifications to your
existing project source code, or especially to the build system, are necessary for that to work. The tree of transitive
dependencies per project is written out as [ABCD](https://github.com/nexB/aboutcode/tree/master/aboutcode-data)-style
YAML (or JSON, see `-f`) files to the specified output directory (`-o`) whose inner structure mirrors the one from the
input directory. The output files exactly document the status quo of all package-related meta-data. They can and
probably need to be further processed or manually edited before passing them to one of the other tools.

### [graph](./graph/src/main/kotlin)

In order to quickly visualize dependency information from an analysis the Graph tool can be used. Given a dependencies
file (`-d`) it diplays a simple representation of the dependency graph in a GUI. The graph is interactive in the sense
that nodes can be dragged & dropped with the mouse to rearrange them for a better overview.

### [downloader](./downloader/src/main/kotlin)

Taking a single ABCD-syle dependencies file as the input (`-d`), the Downloader retrieves the source code of all
contained packages to the specified output directory (`-o`). The Downloader takes care of things like normalizing URLs
and using the [appropriate VCS tool](./downloader/src/main/kotlin/vcs) to checkout source code from version control.

### [scanner](./scanner/src/main/kotlin)

This tool wraps underlying license / copyright scanners with a common API. This way all supported scanners can be used
in the same way to easily run them and compare their results. If passed a dependencies analysis file (`-d`), the Scanner
will automatically download the sources of the dependencies via the Downloader and scan them afterwards. In order to not
download or scan any previously scanned sources, the Scanner can be configured (`-c`) to use a remote cache, hosted
e.g. on [Artifactory](./scanner/src/main/kotlin/ArtifactoryCache.kt) or S3 (not yet implemented). Using the example of
configuring an Artifactory cache, the YAML-based configuration file would look like:

```yaml
scanner:
  cache:
    type: Artifactory
    url: "https://artifactory.domain.com/artifactory/generic-repository-name"
    apiToken: $ARTIFACTORY_API_KEY
```

## Tutorial

This tutorial gives a brief introduction how the tools work together using the NPM package
[mime-types](https://www.npmjs.com/package/mime-types) as example. It will lead through the main steps in running ORT:

* Install ORT.
* Analyze the dependencies of `mime-types` using the `analyzer`.
* Scan the source code of `mime-types` and its dependencies using the `scanner`. 

**1. Prerequisites**

ORT is compatible with Linux, Mac, and Windows. This tutorial assumes that you are running on Linux, but it should be
easy to adapt the commands to Windows.

To run ORT the following tools are required:

* Java (version >= 8)
* Git

For some of the supported package managers and SCMs additional tools need to be installed: 

* CVS
* Mercurial
* NPM (required for this tutorial because we scan `mime-types` which is an NPM project)
* SBT
* Subversion
* Yarn

**2. Download & Install ORT**

In future we will provide binaries of the ORT tools, but currently you have to build the tools on your own. First
download the source code from GitHub (replace `[ort-path]` with the path you want to clone ORT to):

```bash
git clone https://github.com/heremaps/oss-review-toolkit.git [ort-path]
```

To build the tools run:

```bash
cd [ort-path]
./gradlew installDist
```

This will create binaries of the tools in their builds folders, for example the analyzer binary can be found in
`analyzer/build/install/analyzer/bin/analyzer`. To get the command line help for tool run it with the `--help` option:

```bash
$ analyzer/build/install/analyzer/bin/analyzer --help
Usage: analyzer [options]
  Options:
  * --input-dir, -i
      The project directory to scan.
  * --output-dir, -o
      The directory to write dependency information to.
    --package-curations-file
      A YAML file that contains package curation data.
    --ignore-versions
      Ignore versions of required tools. NOTE: This may lead to erroneous 
      results. 
      Default: false
    --merge-results
      Merge all results into a single results file. The individual scan 
      results files for each build file will still be created.
      Default: false
    --allow-dynamic-versions
      Allow dynamic versions of dependencies. This can result in unstable 
      results when dependencies use version ranges. This option only affects 
      package managers that support lock files, like NPM.
      Default: false
    --package-managers, -m
      A list of package managers to activate.
      Default: [Gradle, Maven, SBT, NPM, PIP]
    --output-format, -f
      The data format used for dependency information.
      Default: YAML
      Possible Values: [JSON, YAML]
    --debug
      Enable debug logging and keep any temporary files.
      Default: false
    --stacktrace
      Print out the stacktrace for all exceptions.
      Default: false
    --info
      Enable info logging.
      Default: false
    --help, -h
      Display the command line help.
```

**3. Download the Vue.js source code**

Before scanning `mime-types` its source code has to be downloaded. For reliable results we use version 2.1.18 (replace
`[mime-types-path]` with the path you want to clone `mime-types` to):

```bash
git clone https://github.com/jshttp/mime-types.git [mime-types-path]
cd [mime-types-path]
git checkout 2.1.18
```

**4. Run the analyzer on `mime-types`**

The next step is to run the `analyzer`. It will create a JSON or YAML output file containing the full dependency tree of
`mime-types` including the meta-data of `mime-types` and its dependencies.

```bash
# The easiest way to run the analyzer. Be aware that the [output-path] directory must not exist.
[ort-path]/analyzer/build/install/analyzer/bin/analyzer -i [mime-types-path] -o [output-path]

# The command above will create the default YAML output. If you prefer JSON run:
[ort-path]/analyzer/build/install/analyzer/bin/analyzer -i [mime-types-path] -o [output-path] -f JSON

# To get the maximum log output run:
[ort-path]/analyzer/build/install/analyzer/bin/analyzer -i [mime-types-path] -o [output-path] --debug --stacktrace
```

The `analyzer` will search for build files of all supported package managers. In case of `mime-types` it will find the
`package.json` file and write the results of the dependency analysis to a file called `package-json-dependencies.yml`:

```bash
$ analyzer/build/install/analyzer/bin/analyzer -i ~/git/mime-types -o ~/analyzer-results/mime-types
The following package managers are activated:
        Gradle, Maven, SBT, NPM, PIP
Scanning project path:
        [mime-types-path]
NPM projects found in:
        package.json
Resolving NPM dependencies for '[mime-types-path]/package.json'...
Writing results for
        [mime-types-path]/package.json
to
        [output-path]/mime-types/package-json-dependencies.yml
done.
```

The result file will contain information about the `mime-types` package itself, the dependency tree for each scope, and
information about each dependency. The scope names come from the package managers, for NPM packages these are usually
`dependencies` and `devDependencies`, for Maven package it would be `compile`, `runtime`, `test`, and so on.

The structure of the results file is:

```yaml
allowDynamicVersions: false
# Metadata about the mime-types package.
project: 
  id:
    provider: "NPM"
    namespace: ""
    name: "mime-types"
    version: "2.1.18"
  declared_licenses:
  - "MIT"
  aliases: []
  vcs: # Raw VCS metadata as provided by the package.
    type: ""
    url: "https://github.com/jshttp/mime-types.git"
    revision: ""
    path: ""
  vcs_processed: # Normalized metadata created by ORT.
    type: "Git"
    url: "https://github.com/jshttp/mime-types.git"
    revision: "076f7902e3a730970ea96cd0b9c09bb6110f1127"
    path: ""
  homepage_url: ""
  # The dependency trees by scope.
  scopes:
  - name: "dependencies"
    delivered: true
    dependencies:
    - namespace: ""
      name: "mime-db"
      version: "1.33.0"
      dependencies: []
      errors: [] # If an error occured during the dependency analysis of this package it would be in this list.
  - name: "devDependencies"
    delivered: false
    dependencies:
    - namespace: ""
      name: "eslint-config-standard"
      version: "10.2.1"
      dependencies: []
      errors: []
    - namespace: ""
      name: "eslint-plugin-import"
      version: "2.8.0"
      dependencies:
      - namespace: ""
        name: "builtin-modules"
        version: "1.1.1"
        dependencies: []
        errors: []
    # ...
# Detailed metadata about each package from the dependency trees.
packages:
- id:
    provider: "NPM"
    namespace: ""
    name: "abbrev"
    version: "1.0.9"
  declared_licenses:
  - "ISC"
  description: "Like ruby's abbrev module, but in js"
  homepage_url: "https://github.com/isaacs/abbrev-js#readme"
  binary_artifact:
    url: "https://registry.npmjs.org/abbrev/-/abbrev-1.0.9.tgz"
    hash: "91b4792588a7738c25f35dd6f63752a2f8776135"
    hash_algorithm: "SHA-1"
  source_artifact:
    url: ""
    hash: ""
    hash_algorithm: ""
  vcs:
    type: "git"
    url: "git+ssh://git@github.com/isaacs/abbrev-js.git"
    revision: "c386cd9dbb1d8d7581718c54d4ba944cc9298d6f"
    path: ""
  vcs_processed:
    type: "Git"
    url: "ssh://git@github.com/isaacs/abbrev-js.git"
    revision: "c386cd9dbb1d8d7581718c54d4ba944cc9298d6f"
    path: ""
# ...
#  Finally a list of errors that happened during dependency analysis. Fortunately empty in this case.
errors: []
```

If you try the commands above with a different NPM package that does not have a
[package-lock.json](https://docs.npmjs.com/files/package-locks) (or `npm-shrinkwrap.json` or `yarn.lock`) the analyzer
will terminate with an error message like this: 

```
ERROR - Analysis for these projects did not complete successfully:
[npm-project-path]/package.json
```

This means that there have been issues with the dependency resolution of these packages. The reasons for these errors
can be found in the log output of the `analyzer` or in the results file:

```
Resolving NPM dependencies for '[npm-project-path]/package.json'...
17:11:16.683 ERROR - Resolving dependencies for 'package.json' failed with: No lockfile found in [npm-project-path], dependency versions are unstable.
```

This happens because without a [lockfile](https://docs.npmjs.com/files/package-locks) the versions of transitive
dependencies could change at any time. Therefore ORT checks for the presence of a lockfile to generate reliable results.
This check can be disabled with the `--allow-dynamic-versions` option.

**5. Run the scanner**

To scan the source code of `mime-types` and its dependencies the source code of `mime-types` and all its dependencies
needs to be downloaded. The `downloader` tool could be used for this, but it is also integrated in the `scanner` tool,
so the scanner will automatically download the source code if the required VCS metadata could be obtained.

ORT is designed to integrate lots of different scanners and is not limited to license scanners, technically any tool
that explores the source code of a software package could be integrated. Currently these scanners are available:

* [BoyterLc](https://github.com/boyter/lc)
* [Licensee](https://github.com/benbalter/licensee)
* [ScanCode](https://github.com/nexB/scancode-toolkit)

The actual scanner does not have to run on the same machine, for example we will soon integrate the
[ClearlyDefined](https://clearlydefined.io/) scanner backend which will perform the actual scanning remotely.

For this tutorial we will use `ScanCode`. You do not have to install the tool manually, it will automatically be
bootstrapped by the `scanner`.

As for the `analyzer` you can get the command line options for the `scanner` using the `--help` option:

```bash
$ scanner/build/install/scanner/bin/scanner --help
Usage: scanner [options]                                                                                                                                                                                                                                                                     
  Options:                                                                                                                                                                                                                                                                                   
  * --output-dir, -o                                                                                                                                                                                                                                                                         
      The output directory to store the scan results in.                                                                                                                                                                                                                                     
    --summary-format, -f                                                                                                                                                                                                                                                                     
      The list of file formats for the summary files.                                                                                                                                                                                                                                        
      Default: [YAML]                                                                                                                                                                                                                                                                        
    --dependencies-file, -d                                                                                                                                                                                                                                                                  
      The dependencies analysis file to use. Source code will be downloaded                                                                                                                                                                                                                  
      automatically if needed. This parameter and --input-path are mutually                                                                                                                                                                                                                  
      exclusive.                                                                                                                                                                                                                                                                             
    --input-path, -i                                                                                                                                                                                                                                                                         
      The input directory or file to scan. This parameter and                                                                                                                                                                                                                                
      --dependencies-file are mutually exclusive.                                                                                                                                                                                                                                            
    --download-dir                                                                                                                                                                                                                                                                           
      The output directory for downloaded source code. Defaults to                                                                                                                                                                                                                           
      <output-dir>/downloads.                                                                                                                                                                                                                                                                
    --scopes
      The list of scopes that shall be scanned. Works only with the 
      --dependencies-file parameter. If empty, all scopes are scanned.
      Default: []
    --scanner, -s
      The scanner to use.
      Default: ScanCode
    --config, -c
      The path to the configuration file.
    --info
      Enable info logging.
      Default: false
    --debug
      Enable debug logging and keep any temporary files.
      Default: false
    --stacktrace
      Print out the stacktrace for all exceptions.
      Default: false
    --help, -h
      Display the command line help.
```

The `mime-types` package has only one dependency in the `depenencies` scope, but a lot of dependencies in the
`devDependencies` scope. Scanning all of the `devDependencies` would take a lot of time, so we will only run the
scanner on the `dependencies` scope in this tutorial. If you also want to scan the `devDependencies` it is strongly
advised to configure a cache for the scan results as documented above to speed up repeated scans.

```bash
$ scanner/build/install/scanner/bin/scanner -d [analyzer-output-path]/package-json-dependencies.yml -o [scanner-output-path] --scopes dependencies
Using scanner 'ScanCode'.
Limiting scan to scopes [dependencies]
Using processed VcsInfo(type=Git, url=https://github.com/jshttp/mime-types.git, revision=076f7902e3a730970ea96cd0b9c09bb6110f1127, path=).
Original was VcsInfo(type=, url=https://github.com/jshttp/mime-types.git, revision=, path=).
Running ScanCode version 2.2.1.post277.4d68f9377 on directory '[scanner-output-path]/downloads/mime-types/2.1.18'.
Stored ScanCode results in '[scanner-output-path]/scanResults/mime-types-2.1.18_scancode.json'.
Using processed VcsInfo(type=Git, url=https://github.com/jshttp/mime-db.git, revision=e7c849b1c70ff745a4ae456a0cd5e6be8b05c2fb, path=).
Original was VcsInfo(type=git, url=git+https://github.com/jshttp/mime-db.git, revision=e7c849b1c70ff745a4ae456a0cd5e6be8b05c2fb, path=).
Running ScanCode version 2.2.1.post277.4d68f9377 on directory '[scanner-output-path]/downloads/mime-db/1.33.0'.
Stored ScanCode results in '[scanner-output-path]/scanResults/mime-db-1.33.0_scancode.json'.
Declared licenses for 'NPM::mime-types:2.1.18': MIT
Detected licenses for 'NPM::mime-types:2.1.18': MIT
Declared licenses for 'NPM::mime-db:1.33.0': MIT
Detected licenses for 'NPM::mime-db:1.33.0': MIT
Writing scan summary to [scanner-output-path]/scan-summary.yml.
```

As you can see from the output the licenses detected by `ScanCode` match the licenses declared by the packages. This is
because we scanned a small and well-maintained package in this example, but if you run the scan on a bigger project you
will see that `ScanCode` often finds more licenses than are declared by the packages.

**6. Curate the metadata**

In the example above everything went well because the VCS information provided by the packages was correct, but this is
not always the case. Often the metadata of packages has no VCS information, points to outdated repositories, or the
repositories are not correctly tagged. Because this information can not always be fixed in remote packages ORT provides
a mechanism to curate metadata of packages.

These curations can be configured in a YAML file that has to be passed to the `analyzer`. The data from the curations
file will overwrite the metadata provided by the packages themselves. This way it is possible to fix borken VCS URLs or
provide the location of source artifacts. The structure of the curations file is:

```yaml
# Example for a complete curation object:
#- id: "Maven:org.hamcrest:hamcrest-core:1.3"
#  curations:
#    declared_licenses:
#    - "license a"
#    - "license b"
#    description: "curated description"
#    homepage_url: "http://example.com"
#    binary_artifact:
#      url: "http://example.com/binary.zip"
#      hash: "ddce269a1e3d054cae349621c198dd52"
#      hash_algorithm: "MD5"
#    source_artifact:
#      url: "http://example.com/sources.zip"
#      hash: "ddce269a1e3d054cae349621c198dd52"
#      hash_algorithm: "MD5"
#    vcs:
#      type: "git"
#      url: "http://example.com/repo.git"
#      revision: "1234abc"
#      path: "subdirectory"

# A few examples:

# Repository moved to https://gitlab.ow2.org.
- id: "Maven:asm:asm" # No version means the curation will be applied to all versions of the package.
  curations:
    vcs:
      type: "git"
      url: "https://gitlab.ow2.org/asm/asm.git"

# Revisions found by comparing NPM packages with the sources from https://github.com/olov/ast-traverse.
- id: "NPM::ast-traverse:0.1.0"
  curations:
    vcs:
      revision: "f864d24ba07cde4b79f16999b1c99bfb240a441e"
- id: "NPM::ast-traverse:0.1.1"
  curations:
    vcs:
      revision: "73f2b3c319af82fd8e490d40dd89a15951069b0d"
```

In future we will integrate [ClearlyDefined](https://clearlydefined.io/) as a source for curated metadata. Until then,
and also for curations for internal packages that cannot be published, the curations file can be used.

## Development

The toolkit is written in [Kotlin](https://kotlinlang.org/) and uses [Gradle](https://gradle.org/) as the build system.
We recommend the [IntelliJ IDEA Community Edition](https://www.jetbrains.com/idea/download/) as the IDE which can
directly import the Gradle build files.

The most important root project Gradle tasks are listed in the table below.

| Task        | Purpose                                                           |
| ----------- | ----------------------------------------------------------------- |
| assemble    | Build the JAR artifacts for all projects                          |
| detektCheck | Run static code analysis on all projects                          |
| test        | Run unit tests for all projects                                   |
| funTest     | Run functional tests for all projects                             |
| installDist | Build all projects and install the start scripts for distribution |

## License

Copyright (c) 2017-2018 HERE Europe B.V.

See the [LICENSE](./LICENSE) file in the root of this project for license details.
