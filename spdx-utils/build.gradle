plugins {
    // Apply core plugins.
    id 'antlr'
    id 'java-library'

    // Apply third-party plugins.
    id 'at.bxm.svntools'
}

generateGrammarSource {
    arguments += '-visitor'
}

compileKotlin.dependsOn(generateGrammarSource)

idea.project.settings {
    taskTriggers {
        afterSync tasks.getByName('generateGrammarSource')
        beforeBuild tasks.getByName('generateGrammarSource')
    }
}

dependencies {
    antlr "org.antlr:antlr4:$antlrVersion"

    api "com.fasterxml.jackson.core:jackson-databind:$jacksonVersion"

    implementation "commons-codec:commons-codec:$commonsCodecVersion"

    testImplementation "com.fasterxml.jackson.module:jackson-module-kotlin:$jacksonVersion"
}

task importScanCodeLicenseTexts(type: at.bxm.gradleplugins.svntools.tasks.SvnExport) {
    group = 'SPDX'
    description = 'Imports license texts from the ScanCode repository.'

    svnUrl = 'https://github.com/nexB/scancode-toolkit/trunk/src/licensedcode/data/licenses'
    targetDir = "$buildDir/SvnExport/licenses/scancode-toolkit"
    outputs.dir targetDir
}

task importSpdxLicenseTexts(type: at.bxm.gradleplugins.svntools.tasks.SvnExport) {
    group = 'SPDX'
    description = 'Imports license texts from the SPDX repository.'

    svnUrl = 'https://github.com/spdx/license-list-data/trunk/text'
    targetDir = "$buildDir/SvnExport/licenses/spdx"
    outputs.dir targetDir
}

task importLicenseTexts {
    group = 'SPDX'
    description = 'Imports license texts from all known sources.'
    dependsOn tasks.matching { it.name ==~ /import.+LicenseTexts/ }
    outputs.files dependsOn.collectMany { it*.outputs.files }
}

def getLicenseHeader(int fromYear = 2017, int toYear = java.time.Year.now().value) {
    """\
        /*
         * Copyright (C) $fromYear-$toYear HERE Europe B.V.
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *     http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         *
         * SPDX-License-Identifier: Apache-2.0
         * License-Filename: LICENSE
         */

     """.stripIndent()
}

def licenseToEnumEntry(String id, Map<String, String> meta) {
    def enumName = id.toUpperCase().replaceAll('[-\\.]', '_').replace('+', 'PLUS')
    if (enumName[0].isNumber()) {
        enumName = "_$enumName"
    }

    return [meta.deprecated ? "$enumName(\"$id\", true)" : "$enumName(\"$id\")", "/** ${meta.name} */"]
}

def generateEnumClass(String taskName, String description, String jsonUrl, String className, String resourcePath,
        Closure collectIds) {
    logger.quiet("Fetching $description list...")

    def jsonSlurper = new groovy.json.JsonSlurper()
    def json = jsonSlurper.parse(jsonUrl.toURL())
    def ids = collectIds(json)
    logger.quiet("Found ${ids.size()} SPDX $description identifiers.")

    def enumFile = file("src/main/kotlin/${className}.kt")
    logger.quiet("Writing enum entries to file '$enumFile'...")

    enumFile.write(getLicenseHeader())
    enumFile.append("""\
            package com.here.ort.spdx

            /**
             * An enum containing all SPDX $description IDs. This class is generated by the Gradle task
             * '$taskName'.
             */
            enum class $className(
                    /**
                     * The id of the $description.
                     */
                    val id: String,

                    /**
                     * Whether the [id] is deprecated or not.
                     */
                    val deprecated: Boolean = false
            ) {
            """.stripIndent())

    def enumValues = ids.collectEntries { id, meta ->
        licenseToEnumEntry(id, meta)
    }.sort().collect { entry, comment ->
        "    $comment\n    $entry"
    }.join(',\n') + ';'

    enumFile.append(enumValues)
    enumFile.append("""

                companion object {
                    /**
                     * Return the enum value for the given [id], or null if it is no SPDX $description id.
                     */
                    fun forId(id: String) = ${className}.values().find { it.id == id }
                }

                /**
                 * The full $description text as a string.
                 */
                val text by lazy { javaClass.getResource("/$resourcePath/\$id").readText() }
            }
            """.stripIndent())

    logger.quiet("Generated SPDX $description enum file '$enumFile'.")

    return ids
}

def generateLicenseTextResources(String description, Map<String, Map<String, String>> ids, String resourcePath) {
    logger.quiet("Determining SPDX $description texts...")

    def scanCodeLicensePath = "$buildDir/SvnExport/licenses/scancode-toolkit"
    def spdxIdToScanCodeKey = [:]

    file(scanCodeLicensePath).listFiles({ it.name.endsWith('.yml') } as FileFilter).each { file ->
        file.readLines().each { line ->
            def keyAndValue = line.split(/^spdx_license_key:/, 2)
            if (keyAndValue.size() == 2) {
                spdxIdToScanCodeKey[keyAndValue.last().trim()] = file.name - '.yml'
            }
        }
    }

    ids.each { id, meta ->
        def resourceFile = file("src/main/resources/$resourcePath/$id")

        // Prefer the texts from ScanCode as these have better formatting than those from SPDX.
        def candidates = [
                "$scanCodeLicensePath/${spdxIdToScanCodeKey[id]}.LICENSE",
                "$buildDir/SvnExport/licenses/spdx/${id}.txt"
        ]

        if (meta.deprecated) {
            candidates += "$buildDir/SvnExport/licenses/spdx/deprecated_${id}.txt"
        }

        def i = candidates.iterator()
        while (true) {
            if (i.hasNext()) {
                def candidate = i.next()

                try {
                    def licenseFile = file(candidate)
                    def lines = licenseFile.readLines('UTF-8').collect { it.replaceAll(/\s+$/, '') }
                            .reverse().dropWhile { it.empty }.reverse().dropWhile { it.empty }
                    resourceFile.write(lines.join('\n') + '\n', 'UTF-8')
                    logger.quiet("Got $description text for id '$id' from:\n\t$licenseFile.")
                } catch (FileNotFoundException e) {
                    continue
                }

                break
            } else {
                throw new GradleException("Failed to determine $description text for '$id' from any of $candidates.")
            }
        }
    }
}

task generateLicenseRefTextResources(dependsOn: importScanCodeLicenseTexts) {
    group = 'SPDX'
    description = 'Generates the LicenseRef text resources.'
    finalizedBy cleanImportScanCodeLicenseTexts

    doLast {
        def licensesDir = file("$buildDir/SvnExport/licenses/scancode-toolkit")
        def resourcesDir = file('src/main/resources/licenserefs').tap { mkdirs() }
        licensesDir.listFiles({ it.name.endsWith('.yml') && !it.name.endsWith('-exception.yml')} as FileFilter).each {
            def isSpdxLicense = it.readLines().any { it.startsWith('spdx_license_key: ') }
            if (!isSpdxLicense) {
                def baseName = it.name.take(it.name.lastIndexOf('.'))
                def licenseFile = new File(licensesDir, "${baseName}.LICENSE")
                if (licenseFile.file) {
                    def resourceFile = new File(resourcesDir, baseName)
                    def lines = licenseFile.readLines('UTF-8').collect { it.replaceAll(/\s+$/, '') }
                            .reverse().dropWhile { it.empty }.reverse().dropWhile { it.empty }
                    resourceFile.write(lines.join('\n') + '\n', 'UTF-8')
                } else {
                    logger.warn("No license text found for license '$baseName'.")
                }
            }
        }
    }
}

task generateSpdxLicenseEnum(dependsOn: importLicenseTexts) {
    group = 'SPDX'
    description = 'Generates the enum class of SPDX license ids and their associated texts as resources.'
    finalizedBy cleanImportLicenseTexts

    doLast {
        def description = 'license'
        def resourcePath = 'licenses'
        def ids = generateEnumClass(
                name,
                description,
                'https://raw.githubusercontent.com/spdx/license-list-data/master/json/licenses.json',
                'SpdxLicense',
                resourcePath,
                { json ->
                    json.licenses.collectEntries {
                        [it['licenseId'], [name: it['name'], deprecated: it['isDeprecatedLicenseId']]]
                    }
                }
        )
        generateLicenseTextResources(description, ids, resourcePath)
    }
}

task generateSpdxLicenseExceptionEnum(dependsOn: importLicenseTexts) {
    group = 'SPDX'
    description = 'Generates the enum class of SPDX license exception ids and their associated texts as resources.'
    finalizedBy cleanImportLicenseTexts

    doLast {
        def description = 'license exception'
        def resourcePath = 'exceptions'
        def ids = generateEnumClass(
                name,
                description,
                'https://raw.githubusercontent.com/spdx/license-list-data/master/json/exceptions.json',
                'SpdxLicenseException',
                resourcePath,
                { json ->
                    json.exceptions.collectEntries {
                        [it['licenseExceptionId'], [name: it['name'], deprecated: it['isDeprecatedLicenseId']]]
                    }
                }
        )
        generateLicenseTextResources(description, ids, resourcePath)
    }
}

task generateSpdxEnums {
    group = 'SPDX'
    description = 'Generates the enum classes of SPDX license and exception ids and their associated texts as resources.'
    dependsOn tasks.matching { it.name ==~ /generateSpdx.+Enum/ }
}
