plugins {
    id 'antlr'
    id 'at.bxm.svntools'
}

// Apply core plugins.
apply plugin: 'java-library'

generateGrammarSource {
    arguments += '-visitor'
}

compileKotlin.dependsOn(generateGrammarSource)

idea.project.settings {
    taskTriggers {
        afterSync tasks.getByName('generateGrammarSource')
    }
}

dependencies {
    antlr "org.antlr:antlr4:$antlrVersion"

    api "com.fasterxml.jackson.core:jackson-databind:$jacksonVersion"

    implementation "commons-codec:commons-codec:$commonsCodecVersion"

    testImplementation "com.fasterxml.jackson.module:jackson-module-kotlin:$jacksonVersion"
}

task importScanCodeLicenseTexts(type: at.bxm.gradleplugins.svntools.tasks.SvnExport) {
    group = 'SPDX'
    description = 'Imports license texts from the ScanCode repository.'

    svnUrl = 'https://github.com/nexB/scancode-toolkit/trunk/src/licensedcode/data/licenses'
    targetDir = "$buildDir/SvnExport/licenses/scancode-toolkit"
    outputs.dir targetDir
}

task importSpdxLicenseTexts(type: at.bxm.gradleplugins.svntools.tasks.SvnExport) {
    group = 'SPDX'
    description = 'Imports license texts from the SPDX repository.'

    svnUrl = 'https://github.com/spdx/license-list-data/trunk/text'
    targetDir = "$buildDir/SvnExport/licenses/spdx"
    outputs.dir targetDir
}

task importLicenseTexts {
    group = 'SPDX'
    description = 'Imports license texts from all known sources.'
    dependsOn tasks.matching { it.name ==~ /import.+LicenseTexts/ }
    outputs.files dependsOn.collectMany { it*.outputs.files }
}

def getLicenseHeader(int fromYear = 2017, int toYear = java.time.Year.now().value) {
    """\
        /*
         * Copyright (C) $fromYear-$toYear HERE Europe B.V.
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *     http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         *
         * SPDX-License-Identifier: Apache-2.0
         * License-Filename: LICENSE
         */

     """.stripIndent()
}

def licenseToEnumEntry(String license) {
    def enumName = license.toUpperCase().replaceAll('[-\\.]', '_').replace('+', 'PLUS')
    if (enumName[0].isNumber()) {
        enumName = "_$enumName"
    }
    return "$enumName(\"$license\")"
}

def generateEnumClass(String taskName, String description, String jsonUrl, String className, String resourcePath,
        Closure collectIds) {
    logger.quiet("Fetching $description list...")

    def jsonSlurper = new groovy.json.JsonSlurper()
    def json = jsonSlurper.parse(jsonUrl.toURL())
    def ids = collectIds(json)

    logger.quiet("Found ${ids.size()} SPDX $description identifiers.")

    def enumFile = file("src/main/kotlin/${className}.kt")
    enumFile.write(getLicenseHeader())
    enumFile.append("""\
            package com.here.ort.spdx

            /**
             * An enum containing all SPDX $description IDs. This class is generated by the Gradle task
             * '$taskName'.
             */
            enum class $className(val id: String) {
            """.stripIndent())

    def enumValues = ids.collect { "    ${licenseToEnumEntry(it.toString())}" }.sort().join(',\n') + ';'
    enumFile.append(enumValues)
    enumFile.append("""

                companion object {
                    /**
                     * Return the enum value for the given [id], or null if it is no SPDX $description id.
                     */
                    fun forId(id: String) = ${className}.values().find { it.id == id }
                }

                /**
                 * The full $description text as a string.
                 */
                val text by lazy { javaClass.getResource("/$resourcePath/\$id").readText() }
            }
            """.stripIndent())

    logger.quiet("Generated SPDX $description enum file '$enumFile'.")

    return ids
}

def generateLicenseTextResources(String description, List<String> ids, String resourcePath) {
    logger.quiet("Determining SPDX $description texts...")

    ids.each { id ->
        def resourceFile = file("src/main/resources/$resourcePath/$id")

        // Prefer the texts from ScanCode as these have better formatting than those from SPDX.
        def candidates = [
                "$buildDir/SvnExport/licenses/scancode-toolkit/${id.toLowerCase()}.LICENSE",
                "$buildDir/SvnExport/licenses/spdx/${id}.txt",
                "$buildDir/SvnExport/licenses/spdx/deprecated_${id}.txt"
        ]

        def i = candidates.iterator()
        while (true) {
            if (i.hasNext()) {
                def candidate = i.next()

                try {
                    def text = file(candidate).getText('UTF-8')
                    if (!text.endsWith('\n')) text += '\n'
                    resourceFile.write(text, 'UTF-8')
                } catch (FileNotFoundException e) {
                    logger.quiet("Falling back to license text from SPDX for '$id'.")
                    continue
                }

                break
            } else {
                throw new GradleException("Failed to determine $description text for id '$id' from any of $candidates.")
            }
        }
    }
}

task generateSpdxLicenseEnum(dependsOn: importLicenseTexts) {
    group = 'SPDX'
    description = 'Generates the enum class of SPDX license ids and their associated texts as resources.'
    finalizedBy cleanImportLicenseTexts

    doLast {
        def description = 'license'
        def resourcePath = 'licenses'
        def ids = generateEnumClass(
                name,
                description,
                'https://raw.githubusercontent.com/spdx/license-list-data/master/json/licenses.json',
                'SpdxLicense',
                resourcePath,
                { json -> json.licenses.collect { it['licenseId'] } }
        )
        generateLicenseTextResources(description, ids, resourcePath)
    }
}

task generateSpdxLicenseExceptionEnum(dependsOn: importLicenseTexts) {
    group = 'SPDX'
    description = 'Generates the enum class of SPDX license exception ids and their associated texts as resources.'
    finalizedBy cleanImportLicenseTexts

    doLast {
        def description = 'license exception'
        def resourcePath = 'exceptions'
        def ids = generateEnumClass(
                name,
                description,
                'https://raw.githubusercontent.com/spdx/license-list-data/master/json/exceptions.json',
                'SpdxLicenseException',
                resourcePath,
                { json -> json.exceptions.collect { it['licenseExceptionId'] } }
        )
        generateLicenseTextResources(description, ids, resourcePath)
    }
}

task generateSpdxEnums {
    group = 'SPDX'
    description = 'Generates the enum classes of SPDX license and exception ids and their associated texts as resources.'
    dependsOn tasks.matching { it.name ==~ /generateSpdx.+Enum/ }
}
