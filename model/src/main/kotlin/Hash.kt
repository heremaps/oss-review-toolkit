/*
 * Copyright (C) 2017-2019 HERE Europe B.V.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 * License-Filename: LICENSE
 */

package com.here.ort.model

import com.fasterxml.jackson.core.JsonGenerator
import com.fasterxml.jackson.core.JsonParser
import com.fasterxml.jackson.databind.DeserializationContext
import com.fasterxml.jackson.databind.JsonNode
import com.fasterxml.jackson.databind.SerializerProvider
import com.fasterxml.jackson.databind.deser.std.StdDeserializer
import com.fasterxml.jackson.databind.ser.std.StdSerializer

import com.here.ort.utils.hash
import com.here.ort.utils.toHexString

import java.io.File
import java.lang.reflect.InvocationTargetException
import java.util.Base64

import kotlin.reflect.full.primaryConstructor

/**
 * A sealed class of supported hash algorithms, providing the [names] a hash can be referred by (where the first name in
 * the list is the default name), a [Regex][valueRegex] which all values have to match, the concrete hash [value], and a
 * flag indicating whether values for this hash [can be calculated][canCalculate].
 */
sealed class Hash(val names: List<String>, val valueRegex: Regex, val value: String, val canCalculate: Boolean = true) {
    companion object {
        /**
         * Create a hash from the given [value].
         */
        fun create(value: String): Hash {
            if (value.isEmpty()) return None()

            // Check for a Support Subresource Integrity (SRI) hash, see
            // https://w3c.github.io/webappsec-subresource-integrity/
            val splitValue = value.split('-')
            if (splitValue.size == 2) {
                val decodedValue = Base64.getDecoder().decode(splitValue.last()).toHexString()
                return create(decodedValue, splitValue.first().toUpperCase())
            }

            // Iterate over sealed sub-classes in declaration order. In case of overlapping [valueRegex] patters more
            // generic patters should be declared later.
            return Hash::class.sealedSubclasses.mapNotNull {
                it.primaryConstructor?.takeIf { it.parameters.size == 1 }
            }.mapNotNull {
                try {
                    it.call(value)
                } catch (e: InvocationTargetException) {
                    null
                }
            }.firstOrNull() ?: Unknown(value)
        }

        /**
         * Create a hash from the given [value] and [name]. This is mostly used for deserialization to verify the name
         * matches the algorithm determined by the value.
         */
        fun create(value: String, name: String) =
            create(value).also {
                require(name in it.names) {
                    "Invalid '${it.javaClass.simpleName}' hash name '$name', must be contained in ${it.names}."
                }
            }
    }

    init {
        requireNotNull(valueRegex.matchEntire(value)) {
            "Invalid '${javaClass.simpleName}' hash value '$value', has to match $valueRegex."
        }
    }

    /**
     * Determine whether two hash values generated by the same hash algorithm are equal.
     */
    override fun equals(other: Any?) = other is Hash && other::class == this::class && other.value == this.value

    /**
     * Return the hash code of the hash value.
     */
    override fun hashCode() = value.hashCode()

    /**
     * Verify that the [file] matches this hash.
     */
    fun verify(file: File): Boolean {
        require(canCalculate) {
            "Cannot calculate values for '${javaClass.simpleName}' hash."
        }

        return file.hash(names.first()) == value
    }

    /**
     * The Message-Digest 5 hash algorithm that was used to calculate the [value],
     * see [MD5](https://en.wikipedia.org/wiki/MD5).
     */
    class Md5(value: String) : Hash(listOf("MD5"), Regex("[0-9A-Fa-f]{32}"), value)

    /**
     * The Secure Hash Algorithm 1 that was used to calculate the [value],
     * see [SHA-1](https://en.wikipedia.org/wiki/SHA-1).
     */
    class Sha1(value: String) : Hash(listOf("SHA-1", "SHA1"), Regex("[0-9A-Fa-f]{40}"), value)

    /**
     * The Secure Hash Algorithm 2 with 256 bits that was used to calculate the [value],
     * see [SHA-256](https://en.wikipedia.org/wiki/SHA-256).
     */
    class Sha256(value: String) : Hash(listOf("SHA-256", "SHA256"), Regex("[0-9A-Fa-f]{64}"), value)

    /**
     * The Secure Hash Algorithm 2 with 384 bits that was used to calculate the [value],
     * see [SHA-384](https://en.wikipedia.org/wiki/SHA-384).
     */
    class Sha384(value: String) : Hash(listOf("SHA-384", "SHA384"), Regex("[0-9A-Fa-f]{96}"), value)

    /**
     * The Secure Hash Algorithm 2 with 512 bits that was used to calculate the [value],
     * see [SHA-512](https://en.wikipedia.org/wiki/SHA-512).
     */
    class Sha512(value: String) : Hash(listOf("SHA-512", "SHA512"), Regex("[0-9A-Fa-f]{128}"), value)

    /**
     * An unknown hash algorithm that was used to calculate the [value].
     */
    class Unknown(value: String) : Hash(listOf("UNKNOWN"), Regex("\\S.+\\S"), value, false)

    /**
     * No hash at all, both [names] and [value] are empty.
     */
    class None : Hash(listOf(""), Regex(""), "", false)
}

class HashDeserializer : StdDeserializer<Hash>(Hash::class.java) {
    override fun deserialize(p: JsonParser, ctxt: DeserializationContext): Hash {
        val node = p.codec.readTree<JsonNode>(p)
        return if (node.isTextual) {
            val hashValue = node.textValue()
            if (p.nextFieldName() == "hash_algorithm") {
                val hashAlgorithm = p.nextTextValue()
                Hash.create(hashValue, hashAlgorithm)
            } else {
                Hash.create(hashValue)
            }
        } else {
            Hash.create(node["value"].textValue(), node["algorithm"].textValue())
        }
    }
}

class HashSerializer : StdSerializer<Hash>(Hash::class.java) {
    override fun serialize(hash: Hash, gen: JsonGenerator, provider: SerializerProvider) {
        gen.writeStartObject()
        gen.writeStringField("value", hash.value)
        gen.writeStringField("algorithm", hash.names.first())
        gen.writeEndObject()
    }
}
